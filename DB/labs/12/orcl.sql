-- Создайте таблицу Report, содержащую два столбца – id и XML-столбец в базе данных SQL Server.
select * from Report;
create table Report (
    Id number GENERATED BY DEFAULT AS IDENTITY,
    XmlParsed XMLType
);
drop table Report;

-- Создайте процедуру генерации XML. XML должен включать данные из как минимум 3 
-- соединенных таблиц, различные промежуточные итоги и штамп времени
CREATE OR REPLACE FUNCTION generateXML RETURN XMLtype as out_xml xmltype;
BEGIN
    SELECT XMLElement("Root",
        XMLAgg(
            XMLElement("TESTS",
                XMLForest(
                    t.id AS "TestID", 
                    c.developer AS "Developer",
                    td.json_data AS "JSON_DATA",
                    TO_CHAR(sysdate, 'YYYY-MM-DD HH24:MI:SS') as "Date"
                )
            )
        )
    )
    into out_xml
    FROM TEST_DATA td
        JOIN tests t ON td.id = t.data_id
        JOIN commits c on c.id = t.commit;
    return out_xml;
END generateXML;

-- Создайте процедуру вставки этого XML в таблицу Report
create or replace procedure getInsertReport as xmlData XMLtype; 
BEGIN
  xmlData := generateXML();
  INSERT INTO Report (XmlParsed) VALUES (xmlData);
  COMMIT;
END getInsertReport;

begin
    getInsertReport;
end;

select * from Report;

-- Создайте индекс над XML-столбцом в таблице Report
CREATE INDEX PrimaryIndex ON Report(XmlParsed) INDEXTYPE IS XDB.XMLINDEX;

select * from Report;

-- Создайте процедуру извлечения значений элементов и/или атрибутов из XML -столбца в таблице 
-- Report (параметр – значение атрибута или элемента).
CREATE OR REPLACE FUNCTION GetInfoColumnData(XPath IN VARCHAR2) RETURN XMLType
AS
  v_xml XMLType;
BEGIN
  SELECT XMLQuery(XPath PASSING BY VALUE XmlParsed RETURNING CONTENT)
  INTO v_xml
  FROM Report;
  RETURN v_xml;
END GetInfoColumnData;

select GetInfoColumnData('/Root/TESTS/Developer') from dual;

SELECT XMLQuery('/Root/TESTS/Developer' PASSING BY VALUE XmlParsed RETURNING CONTENT)
  FROM Report;